---
description: Contains information about application project. Apply based on project structure rules.
globs: src/Application/**
---


Dependency injection
- [DependencyInjection.cs](mdc:src/Application/DependencyInjection.cs)


## Common folder

"src/Application/Common"

"src/Application/Common/Behaviours"
- contains Mediatr behaviours
- [ValidationBehaviour.cs](mdc:src/Application/Common/Behaviours/ValidationBehaviour.cs)

"src/Application/Common/Interfaces"
- contains interafaces that will be implemented by infrastructure layer


## Enforcement of DDD pattern

communication with database
- use generic repositories to communicate with database
- [IWriteRepository.cs](mdc:src/Application/Common/Interfaces/Repositories/IWriteRepository.cs)
    - note: aggregate roots implement [IAggregateRoot.cs](mdc:src/Domain/Common/IAggregateRoot.cs)
    - you can update only aggregate roots directly in order to enforce domain rules
    - when you want to edit child entity, you have to edit it via aggregate root and save aggregate root as a whole
    - important: do not forget to call `SaveAsync()` in repository when you want to save changes to db
- [IReadRepository.cs](mdc:src/Application/Common/Interfaces/Repositories/IReadRepository.cs)
    - you can read all entities including those that do not implement aggregate roots
    - returns IQueryable to give you higher flexibility when querying items from database
    - important: do not use read repositories in requests, use that only in queries

communication with domain
- you should respect what methods does domain expose and what parameters do they accept
    - when updating some fields, you can not access them directly but have to set them via methods f.e `SetMaxItems(int maxItems)` or when adding todoitem to todolist `AddItem(TodoItem item)`


## Commands and queries

uses mediatr to handle requests from web project
maps entities and dtos with automapper

commands and queries are grouped by entities
- f.e. "src/Application/TodoLists"
- Commands are saved in "src/Application/TodoLists/Commands"
- Queries in "src/Application/TodoLists/Queries"

default values
- Set default values in domain project. Do not set default values in requests in application layer, unless the value is not tied to domain but used elsewhere f.e calling services in infrastructure


### Structure of api and requests

- Each web api endpoint correspond to one request in application layer
- `public async Task<IActionResult> Create(CreateTodoListCommand command)`

update(PUT) requests
- update/put request does not create new items
- consider splitting update requests into multiple endpoints and mediatr requests
    - when it update fields that contain domain logic
        - use PUT request, since all field are usually required
        - such as in todo list example `SetMaxItems(int maxItems)`, create seperate update method `PUT "{id}/MaxItems"`
        - `PUT "{listid}/Items/{itemid}"` when changing list id, which moves todoitem to difference todo list and checks if `MaxItems` are not reached, when item moves
        - otherwise if all properties are set via main method it would be fragile and chaotic
    - updating fields, that are not domain significant such as `Description` or `Colour` may be updated in main patch method `PATCH "{id}"`, since not all fields are usually required in request body
        - also name the request `PatchTodoList` instead of `UpdateTodoList` to distinguish which HTTP method should you use


### Validation

general rules:
- which keywords should properties use in requests
    - it should reflect domain, if property in domain is required, property in request should also be required
    - if property in domain has default value, set property in request to nullable. since if the value will in provided request will be null, we want to skip setting value in order for domain to set its default value
        - when you would check, whether value is null: for reference types use `is not null`, for value types use `.HasValue`
- important: Do not forget to create and update command validators

- if you have int or enum in request, try to make it nullable or required
    - f.e when the user does not provide value for it, then it would map to zero. how should backend know if zero was provided by user or the value was zero, because it was not provided


#### POST Request

- tied to CreateCommand

- below is snippet example, that shows how to set properties in requests and call domain
    ```c#
    ... // request
    public required string Title { get; init; }
    public Optional<string?> Description { get; set; }
    public Optional<Colour> Colour { get; init; }
    public Optional<int> MaxItems { get; init; }

    ... // handler
    var entity = new TodoList
    {
        Title = request.Title
    };
    
    if (request.Description.HasValue)
        entity.SetDescription(request.Description.Value);

    if (request.Colour.HasValue)
        entity.SetColour(request.Colour.Value);

    if (request.MaxItems.HasValue)
        entity.SetMaxItems(request.MaxItems.Value);
    ...
    ```
- similarly to PATCH, not everything has to provided in request body, unlike PUT update requests
- `Title` is required, since aggregate root `TodoList` needs `Title` to be set, when creating new `TodoList`
- `Description` has to use custom struct Optional<string?> and json converter
    - otherwise if we used only nullable `string? Description`, there would be ambiguity, it could mean two things: 
        1. the field was ommited in request body and was set to null by json converter
        2. the field was explicitly set to null by client
    - use this only for properties, that maps to properties in domain, where are set using set method such as `SetDescription(string? description)`, that accepts nullable parameter
    - [Optional.cs](mdc:src/Domain/Common/Optional.cs)
- `Colour` and `MaxItems` are optional, when we look into `TodoList` aggregate root, therefore we also use `Optional<T>`. they have default values set in domain, what means they dont have to be set.
- important: set everything to `Optional<T>`, unless the property in request maps to property in domain, that is required, when creating object such as `Title`.


#### PUT Request

```c#
    public required int Id { get; init; }
    public required DateTime Start { get; init; }
    public required DateTime End { get; init; }
```
- everything has to be set to required, since PUT request requires all fields, since it should not do partial updates
- important: do not skip setting properties, if they are null, set all if possible


#### PATCH Request

```c#
    public required int Id { get; init; }
    public Optional<string> Title { get; init; }
    public Optional<Colour> Colour { get; init; }

```
- similar structure as POST request, but also accepts Id property, which has to be required `required int Id`
- now `Title` is optional, because it is required to be set only when initializing object, but when patching/updating object is already initialized.


### Enums, value objects

use values object and enums directly in requests and dtos
- since asp.net core can serialize and deserialize it directly
- try to assign suitable enums and value object to properties
    - f.e. do not use int for property like priority since [PriorityLevel.cs](mdc:src/Domain/Enums/PriorityLevel.cs) exists


### Authorization

[CurrentUser.cs](mdc:src/Infrastructure/Identity/CurrentUser.cs)
- use to retrieve current information about user to determine its role and permissions
- f.e. admin can retrieve all items, but user can retrieve only items that share his user id


### Transactions

TODO: dokoncit, je to dolezite


### Example commands and queries

"src/Application/TodoLists/Commands/CreateTodoList"
command contains:
    - command and handler in this example located in "src/Application/TodoLists/Commands/CreateTodoList/CreateTodoList.cs"
    - command validator located in "src/Application/TodoLists/Commands/CreateTodoList/CreateTodoListCommandValidator.cs"


#### Create TodoList

command and its handler
- [CreateTodoList.cs](mdc:src/Application/TodoLists/Commands/CreateTodoList/CreateTodoList.cs)

command validator
- [CreateTodoItemCommandValidator.cs](mdc:src/Application/TodoItems/Commands/CreateTodoItem/CreateTodoItemCommandValidator.cs)


#### Update TodoList

is split between multiple commands based on whether we update fields with domain validation and significance like title or maxItems, what have to be validated agains domain
- it would be confusing to update all fields in same endpoint/request including those that have domain significance as i have written earlier

UpdateTodoList
- [UpdateTodoList.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoList/UpdateTodoList.cs)
- [UpdateTodoListCommandValidator.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoList/UpdateTodoListCommandValidator.cs)

UpdateTodoListMaxItems
command and its handler
- [UpdateTodoListMaxItems.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoListMaxItems/UpdateTodoListMaxItems.cs)
- have to call method `SetMaxItems(int maxItems)`, since "TodoList" domain object does not expose max items directly


#### Query TodoList

query and its handler
- uses automapper to map entities and dtos
- dtos are saved in same directory as query
- [GetTodos.cs](mdc:src/Application/TodoLists/Queries/GetTodos/GetTodos.cs)

dtos
- dont forget to set mapping profiles
- [TodoItemDto.cs](mdc:src/Application/TodoLists/Queries/GetTodos/TodoItemDto.cs)
- [TodoListDto.cs](mdc:src/Application/TodoLists/Queries/GetTodos/TodoListDto.cs)


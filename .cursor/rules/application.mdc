---
description: Contains information about application project. Apply based on project structure rules.
globs: src/Application/**
---


Dependency injection
- [DependencyInjection.cs](mdc:src/Application/DependencyInjection.cs)


## Common folder

"src/Application/Common"

"src/Application/Common/Behaviours"
- contains Mediatr behaviours
- [ValidationBehaviour.cs](mdc:src/Application/Common/Behaviours/ValidationBehaviour.cs)

"src/Application/Common/Interfaces"
- contains interafaces that will be implemented by infrastructure layer


## Enforcement of DDD pattern

communication with database
- use generic repositories to communicate with database
- [IWriteRepository.cs](mdc:src/Application/Common/Interfaces/Repositories/IWriteRepository.cs)
    - note: aggregate roots implement [IAggregateRoot.cs](mdc:src/Domain/Common/IAggregateRoot.cs)
    - you can update only aggregate roots directly in order to enforce domain rules
    - when you want to edit child entity, you have to edit it via aggregate root and save aggregate root as a whole
    - important: do not forget to call `SaveAsync()` in repository when you want to save changes to db
- [IReadRepository.cs](mdc:src/Application/Common/Interfaces/Repositories/IReadRepository.cs)
    - you can read all entities including those that do not implement aggregate roots
    - returns IQueryable to give you higher flexibility when querying items from database
    - important: do not use read repositories in requests, use that only in queries

communication with domain
- !important: you should respect what methods does domain expose and what parameters do they accept
    - when updating some fields, you can not access them directly but have to set them via methods f.e `SetMaxItems(int maxItems)` or when adding todoitem to todolist `AddItem(TodoItem item)`
    - or when calling method in domain that accepts nullable parameter also provide nullable variable


## Commands and queries

uses mediatr to handle requests from web project
maps entities and dtos with automapper

commands and queries are grouped by entities
- f.e. "src/Application/TodoLists"
- Commands are saved in "src/Application/TodoLists/Commands"
- Queries in "src/Application/TodoLists/Queries"

default values
- Set default values in domain project. Do not set default values in requests in application layer, unless the value is not tied to domain but used elsewhere f.e calling services in infrastructure

important: which keywords should properties use in requests
- it should reflect domain, if property in domain is required, property in request should also be required
- if property in domain has default value, set property in request to nullable. since if the value will in provided request will be null, we want to skip setting value in order for domain to set its default value
    - when you would check, whether value is null: for reference types use `is not null`, for value types use `.HasValue`


### Structure of api and requests

- Each web api endpoint correspond to one request in application layer
- `public async Task<IActionResult> Create(CreateTodoListCommand command)`

update(PUT) requests
- update/put request does not create new items
- consider splitting update requests into multiple endpoints and mediatr requests
    - when it update fields that contain domain logic
        - use PUT request, since all field are usually required
        - such as in todo list example `SetMaxItems(int maxItems)`, create seperate update method `PUT "{id}/MaxItems"`
        - `PUT "{listid}/Items/{itemid}"` when changing list id, which moves todoitem to difference todo list and checks if `MaxItems` are not reached, when item moves
        - otherwise if all properties are set via main method it would be fragile and chaotic
    - updating fields, that are not domain significant such as `Description` or `Colour` may be updated in main put method `PUT "{id}"`, since not all fields are usually required in request body
        - also name the request `UpdateTodoList` instead of `UpdateTodoList` to distinguish which HTTP method should you use


### Validation

general rules:
- important: all properties are required in requests
- important: Do not forget to create and update command validators

- if you have int or enum in request, try to make it nullable or required
    - f.e when the user does not provide value for it, then it would map to zero. how should backend know if zero was provided by user or the value was zero, because it was not provided

- important: Pozor na databazove obmedzenie ako unique alebo relationship medzi entitami, vsetko treba zvalidovat v CommandValidators. 
    - nachadza sa EF Core konfiguracnych suboroch ako napr. [CenovaPonukaConfiguration.cs](mdc:src/Infrastructure/Data/Configurations/CenovaPonukaConfiguration.cs)
    - Ak je v domene entita unique zvaliduj to


### Enums, value objects

use values object and enums directly in requests and dtos
- since asp.net core can serialize and deserialize it directly
- try to assign suitable enums and value object to properties
    - f.e. do not use int for property like priority since [PriorityLevel.cs](mdc:src/Domain/Enums/PriorityLevel.cs) exists


### Authorization

[CurrentUser.cs](mdc:src/Infrastructure/Identity/CurrentUser.cs)
- use to retrieve current information about user to determine its role and permissions
- f.e. admin can retrieve all items, but user can retrieve only items that share his user id


### Transactions

TODO: dokoncit, je to dolezite


### Example commands and queries

"src/Application/TodoLists/Commands/CreateTodoList"
command contains:
    - command and handler in this example located in "src/Application/TodoLists/Commands/CreateTodoList/CreateTodoList.cs"
    - command validator located in "src/Application/TodoLists/Commands/CreateTodoList/CreateTodoListCommandValidator.cs"


#### Create TodoList

command and its handler
- [CreateTodoList.cs](mdc:src/Application/TodoLists/Commands/CreateTodoList/CreateTodoList.cs)

command validator
- [CreateTodoItemCommandValidator.cs](mdc:src/Application/TodoItems/Commands/CreateTodoItem/CreateTodoItemCommandValidator.cs)


#### Update TodoList

is split between multiple commands based on whether we update fields with domain validation and significance like title or maxItems, what have to be validated agains domain
- it would be confusing to update all fields in same endpoint/request including those that have domain significance as i have written earlier

UpdateTodoList
- [UpdateTodoList.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoList/UpdateTodoList.cs)
- [UpdateTodoListCommandValidator.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoList/UpdateTodoListCommandValidator.cs)

UpdateTodoListMaxItems
command and its handler
- [UpdateTodoListMaxItems.cs](mdc:src/Application/TodoLists/Commands/UpdateTodoListMaxItems/UpdateTodoListMaxItems.cs)
- have to call method `SetMaxItems(int maxItems)`, since "TodoList" domain object does not expose max items directly


#### Query TodoList

query and its handler
- uses automapper to map entities and dtos
- dtos are saved in same directory as query
- [GetTodos.cs](mdc:src/Application/TodoLists/Queries/GetTodos/GetTodos.cs)

dtos
- dont forget to set mapping profiles
- [TodoItemDto.cs](mdc:src/Application/TodoLists/Queries/GetTodos/TodoItemDto.cs)
- [TodoListDto.cs](mdc:src/Application/TodoLists/Queries/GetTodos/TodoListDto.cs)

